# Object(객체)
Chapter 1과 2에서 this binding의 원리를 살펴 보았다. 그럼 대체 객체는 무엇이고 왜 객체를 가리켜야 할까?

## Syntax(구문)
객체는 2가지 형식이 있다.
- 리터럴 형식
```js
// 함수 표현식과 비슷하게 생김
var obj = {
    key: value
};
```

```js
// 함수 선언식
function func() {
    ...
}
```
함수 표현식과 함수 선언식의 끝을 보면 ;(세미콜론) 차이가 있는데, 성능이나 기능상 차이는 없고 관습이라고 한다.


- 생성자 형식
```js
var obj = new Object();
obj.key = value;
```
=> 리터럴 형식은 한 번의 선언으로 다수의 키/값 쌍을 가진 프로터피를 추가할 수 있지만,
생성자 형식은 한 번에 하나의 프로퍼티만 추가 할 수 있다는 차이가 있다. 

=> 결론은 자바스크립트에서는 생성자 형식보다는 리터럴 형식을 권장한다.<br>
찾아보니까 생성자 형식이 가독성과 속도가 더 좋다고 한다.<br>
속도 비교 참고 : http://jsperf.com/new-array-vs-literal/26 

## Type
- 원시 타입
    - string
    - number
    - boolean
    - **null**(콘솔에 typeof null 찍어보면 object라고 나옴 => 언어 자체의 버그라 함)
    - undefined
    - symbol(ECMAScript6에서 추가)

'자바스크립트에서 모든 것은 객체이다.' 라는 말은 옳지 않다.<br>
null 타입을 객체로 오해 할 수 있지만, 객체가 아니다. 

- 내장 객체
    - String
    - Number
    - Boolean
    - Symbol
    - Object
    - Function
    - Array
    - Date
    - RegExp
    - Error

위 몇 가지 내장 객체를 보면 원시 타입을 감싸는 Wrapper 처럼 보이는 것을 내장 객체라고 하는 것 같지만,
내장 객체는 객체의 하위 타입으로 쉽게 생각하면 자바스크립트 엔진에서 기본적으로 가지고 있는 객체를 의미하며, 이외에도 많은 종류가 있다.<br>
undefined는 값을 나타내는 것으로 값이 할당되지 않았음을 의미 한다. 이와 비슷하게 볼 수 있는 null은 개발자가 값이 비어있음을 명시적으로 나타내기 위해 사용한다.<br>

null 체크를 하고 싶을 때는 typeof로 하면 안되고(object가 나옴), 일치연산자(===)를 이용한다.
```js
var nullVar = null;

console.log(typeof nullVar === null);  // false
console.log(nullVar === null);  // true
```

=======팁=======

null, undefined, ''(공백) 검사하는 if문
```js

if(변수) {
    // 원하는 값
}

```
===============


string 원시 타입 같은 경우, 자바스크립트 엔진에서 자동으로 String 내장 객체로 강제 변환하기도 한다.<br>
예를 들어 아래의 코드를 보자.
 ```js
var str = "문자열";

console.log(str);               // 문자열
console.log(str.length);        // 3
 ```
위 코드에서 str.length를 보면 원시 타입 이면서도 프로퍼티를 가지고 있다.<br>
데이터를 저장하는 가장 기본적인 원시 타입이 어떻게 프로퍼티를 갖는가?<br>
string 원시 값에 대해 프로퍼티/메소드를 호출하면 자바스크립트 엔진이 자동으로 String 내장 객체로 변환하여 처리한다.<br>
이와 비슷하게 Number, Boolean도 강제 변환이 가능하다.

또한, Date 내장객체를 생성할 때는 객체의 2가지 형식(리터럴, 생성자)에서 생성자만 사용해야 한다.(리터럴 형식이 없음)

## Contents(내용)
객체의 내용이란 프로퍼티를 의미하며, 프로퍼티는 모두 문자열로 저장이 된다.

엔진은 실제로 어떻게 프로퍼티를 저장할까? 쉽게 생각하면 프로퍼티를 차곡차곡 저장하고 있을 것 같지만, 전혀 그렇지 않다.
객체는 프로퍼티를 담는 컨테이너라고 볼 수 있다. 이러한 객체 컨테이너에 실제로 값을 저장하는 것이 아닌 프로퍼티 값을 가리키는(포인터 같은) 역할을 담당하는 프로퍼티가 담겨있다.

프로퍼티 접근 방식은 아래 코드와 같이 2가지 방법이 있다.
```js
var obj = {
    a: 2
};

obj.a;      // 2를 가지고 있음
obj["a"];   // 똑같이 2를 가지고 있음
```

.a 같은 접근 방식을 '프로퍼티 접근(property access)' 이라고, ["a"]와 같은 접근 방식을 '키 접근(key access)' 이라고 한다.
위 둘다 같은 값을 조회하므로 어느 방법을 사용하든 상관 없다.

하지만 . 뒤에는 식별자 호환 프로퍼티명이 와야하고, [" "] 안에는 UTF-8/유니코드 호환 문자열은 모두 프로퍼티명으로 사용 가능하다는 차이가 있다.


```js
var obj = {
"민혁" : 2,
"민혁@" : 200
};

//console.log(obj."민혁");
console.log(obj["민혁"]);

console.log(obj.민혁@);       // Caught Error
console.log(obj["민혁@"]);    // 200
```

위에서 프로퍼티명은 항상 문자열이라고 했다. 문자열 이외의 다른 원시 값을 사용하면 우선 문자열로 변환된다.
배열 인덱스로 사용하는 숫자도 마찬가지이므로 아래 코드처럼 괜히 객체와 배열 사이에 숫자를 써서 헷갈리는 코드를 만들지 말자.


### 계산된 프로퍼티명
프로퍼티명을 문자열 연산을 이용하여 만드는 것을 의미한다.<br>
사용 방법은 계산된 프로퍼티명을 []로 감싸기만 하면 된다.<br>
단, ES6부터 가능하며 주로 심볼에서 가장 많이 다룬다고 한다.<br>

아래 코드를 보자.

```js
var prefix = "foo";

var obj = {
    [prefix + "bar"]: "hello",
    [prefix + "baz"]: "world"
};

console.log(obj["foobar"]); // hello
console.log(obj["foobaz"]); // world
```


### 배열
배열은 우리가 흔히 알고 있는 [] 형태의 데이터 집합을 의미한다.
```js
var arr = ["foo", 42, "bar"];   // arr.length = 3
arr.baz = "baz";
console.log(arr.length);     // 3   ======> ????????!!!!!!!!!!!!
console.log(arr.baz);
```

저번주에 최적화에 대해 조금 언급되었었는데, 최적화 관점에서 배열은 숫자 인덱스일때가 효율이 가장 좋고, 키/값 저장소는 객체를 사용하는 것이 가장 좋다고 한다.

