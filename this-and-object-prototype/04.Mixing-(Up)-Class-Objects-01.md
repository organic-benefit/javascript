# Chapter 4: Mixing (Up) "Class" Objects

  이번 장에선 인스턴스화(instantiation) , 상속(inheritance) , 다형성(polymorphism) 등<br>
  클래스 관련 기법들을 살펴보기에 앞서서<br>
  클래스 지향(class orientation)을 디자인 패턴으로 알아 보도록 하겠습니다.

  클래스 지향 개념은 javascript 객체 메커니즘과 맞지 않아서,<br>
  많은 개발자 들이 지금까지도 이러한 문제를 극복하고자 확장(mixins) 노력 하고 있습니다.

  Note : 어려운 내용 이지만 정독 하길 바랍니다......쿨럭..

## 클래스 이론...

클래스 상속은 특정 형식의 코드 구조를 나타내며, 이는 실 생활 영역에의 모델링을 하는 방법입니다.<br>
객체지향 또는 클래스 지향(OO or class oriented programming) 프로그래밍에서<br>
데이터는 자신을 기반으로 실행, 작동과 연관이 있으므로 <br>
데이터와 작동을 함께 잘 감싸는 것(캡슐화,encapsulate)이 올바른 설계라고 강조합니다.<br>
바로 이를 두고 **자료구조(data structures)** 라고도 합니다.  

예를 들어 문자열(String)은 보통 단어나 어구를 나타내는데,<br>
여기서 데이터를 신경 쓰는것이 아닌, 데이터로 원하는 작업을 하는 것이 관심사이므로<br>
데이터에 적용 가능한 동작(길이 계산, 데이터 추가, 검색등)을 모두 **String클래스** 의 메소드로 설계합니다.<br>
그리하여 우리는 어떠한 문자를 받더라도 데이터와 동작이 잘 정의된 String클래스의 인스턴스 일 뿐입니다.

클래스는 특정 데이터 구조를 분류하고자 하는 용도로 사용 합니다.<br>
이는 주어진 구조에서 보다 **세부적이고 구체적인 변형 자료구조** 를 도출하는 것입니다.

공통적으로 인용된 사례를 찾아보면, <br>
자동차(Car)는 차량(Vehicle)이라고 하는 좀 더 일반적인 클래스(class)의 구현체 중 하나입니다.

소프트웨어 에서는 차량(Vehicle)과 자동차(Car)의 관계를 모델링 합니다.<br>
차량(Vehicle)에는 엔진같은 추진기관과, 사람을 운송하는 기능, 즉 행동(behaviors)을 함께 정의 합니다.<br>
따라서 차량(Vehicle)에는 거의 모든 유형의 탈것이 포함된다 보시면 됩니다.

그런데 상의한 탈것마다 운송하는 기능을 재 정의 한다면, 올바른 소프트웨어의 설계가 아닐 것 입니다.<br>
그래서 차량(Vehicle)에만 정의를 해 두고, 자동차(Car)는 차량(Vehicle)을 상속 또는 확장(extends)을 받아 정의를 합니다.<br>
즉 자동차(Car)는 차량(Vehicle)의 정의를 **세분화** 한 셈 입니다.

클래스의 또 다른 핵심기능은 **다형성** 입니다.<br>
상위 클래스의 일반적인 동작을 하위 클래스에서 재 정의(override)하는 것을 뜻합니다.<br>
클래스 이론에서는 부모 클래스와 자식 클래스가 특정 메서드 이름을 공유하므로 오버라이드를 하라고 권장 하지만,<br>
javascript 에서는 이러면 코드에서 좌절감을 맛볼 수 있을 것 입니다.<br>


## "Class" Design Pattern

"Iterator", "Observer", "Factory", "Singleton" 처럼 대중적인 디자인 패턴들은 <br>
자주 인용되는 탓에 클래스 역시 디자인 패턴의 일종이란 생각은 안해보았을 것입니다.<br>
그래서 객체 지향이 모든 코드의 토대가 되는 것처럼 생각하는 사람이 많은 이유입니다.

오히려 함수형 프로그래밍을 경험한 사람이라면 <br>
클래스는 단지 디자인 패턴중의 하나란걸 알고 있을 것 입니다.

## JavaScript "Classes"

javascript는 어떤가요? <br>
클래스와 비슷하게 생긴 new 나 instanceof 같은 구문 요소도 있고, <br>
ES6에서는 아예 class라는 키워드가 명세에 정식으로 추가 되기도 하였습니다.<br>
그렇다면 정말 클래스 인가 라는 질문에는 **아니다** 입니다.

클래스는 디자인 패턴 이므로 공을 들이면 얼추 비슷하게 구현은 가능합니다.<br>
그간 JavaScript는 적어도 외관상으로는 클래스 처럼 생긴 구문을 제공하여<br>
클래스 디자인 패턴을 실현 하려하는 욕구를 충족 시켜주려 노력해 해 왔으니까요.

그러나 이는 그럴듯 하게 보일 뿐 입니다.<br>
실제로 안을 들여다 보면은 전혀 다른 방식으로 동작을 한다고 보시면 됩니다.

결론은 클래스는 디자인 패턴중의 한 가지 일뿐이니.<br>
JavaScript에서 클래스를 사용할지 말지는 당사자가 결정해야 할 몫이란 것입니다.


## Class Mechanics(체계)

대부분의 클레스 지향언어(class-oriented languages)는 표준 라이브러리<br>
스택 자료구조를 'Stack'클래스에 구현 해 놓았습니다.

하지만 이 Stack클래스에서 실제로 어떤 작업을 직접 수행 하는건 아닙니다.<br>
Stack클래스는 그저 추상화한 것 뿐이지 **인스턴스화** 해야 비로소 작업을 수행할 구제적인 자료구조가 마련됩니다.

### Building(건축)

클래스와 인스턴스 중심의 사고 방식은 건축 현장에 빗대어 생각할수 있습니다.<br>
건축가(architect)는 건축의 모든 것들을 기획을 하는데, 여기서 건축가는 전반적인 구조만 계획할 뿐입니다.<br>
즉, 건축을 위한 청사진(architectural blue-prints)은 건축가(architect)가 <br>
건축을 하기 위한 **간접적인 계획** 일 뿐입니다.

**클래스가 바로 청사진에 해당 합니다.** 실제로 객체를 얻으려면 클래스에서 무언가를 구현(인스턴스화) 해야 합니다.

일반적으로 청사진을 보고 실제 완공된 건물 내부를 들어가 여기 저기 찾아보는 사람은 없을 것입니다<br>.
당연히 설계도는 관활 기록 보관소 어딘가에 보관 되어 있을 것입니다.<br>
마찬가지로 객체 인스턴스를 통해 클래스에 접근하여 어떤 조작을 가할 일은 없지만,<br>
적어도 어느 클래스로부터 인스턴스화한 것인지 출처를 식별 할수는 있습니다.

클래스와 객체 인스턴스 간의 간접적인 관계 보다는 직접적인 관계를 알아보도록 하겠습니다.

  **클래스는 복사 과정을 거쳐 객채형태로 인스턴스화가 진행 된다.**

아래는 클래스 복사 과정을 나타낸 그림입니다.

![](assets/4-1.png)

[좌 --> 우], [위 --> 아래] 화살표가 복사가 일어나는 방향을 나태내 줍니다.


### Constructor

인스턴스는 보통 클래스명과 동일한 생성자(Constructor) 라는 특별한 메서드로 생성해 줍니다.<br>
생성자의 임무는 인스턴스에 필요한 정보를 초기화 해주는 것이지요.

```javascript
class CoolGuy {
    specialTrick = nothing

    CoolGuy( trick ) {
        specialTrick = trick
    }

    showOff() {
        output( "Here's my trick: ", specialTrick )
    }
}
```

CoolGuy 인스턴스를 생성 하려한다면 생성자를 호출할 것입니다.

```javascript
Joe = new CoolGuy( "jumping rope" )

Joe.showOff() // Here's my trick: jumping rope
```

생성자의 반환값은 객체 이므로 Joe.showOff() 를 호출 하였을때, 해당 내용이 호출된걸 볼수 있습니다.
생성자는 클래스에 속한 메서드 일 뿐이며, 클래스명과 동일하게 해주는게 일반적이고, <br>
새로운 인스턴스를 생성할 거라는 키워드로 **new** 를 앞에 붙여 호출을 해 줍니다.

## 마치며

이 글에서는 클래스 개론과 자바스크립트와의 차이를 알아 보았습니다.<br>
더 깊이 많이 알면 알수록 점점더 자바 스크립트가 이해가 되기 시작하지 않으시나요~?
