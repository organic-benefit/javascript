## this All Makes Sense Now!

### Call-site

this 바인딩의 개념에 대해서 이해하려면 먼저 호출부(함수 호출)부터 확인 하고, this가 가르키는 것이 무엇인지 찾아 봐야 한다.
중요한 것은 call-stack (현재 실행 순간에 우리를 데려 오기 위해 호출 된 함수 스택)에 대해 생각하는 것입니다.

```javascript
function baz() {
    // call-stack is: `baz`
    // so, our call-site is in the global scope

    console.log( "baz" );
    bar(); // <-- call-site for `bar`
}

function bar() {
    // call-stack is: `baz` -> `bar`
    // so, our call-site is in `baz`

    console.log( "bar" );
    foo(); // <-- call-site for `foo`
}

function foo() {
    // call-stack is: `baz` -> `bar` -> `foo`
    // so, our call-site is in `bar`

    console.log( "foo" );
}

baz(); // <-- call-site for `baz`
```

### Nothing But Rules

호출부를 보고 4가지 규칙중 어느 것인지 분별해 보고 우선순위를 확인해 보조록 하자.

#### 1. Default Binding
기본적인 바인딩 규칙 - 단독 함수 실행 ( standalone function invocation )

```javascript
function foo() {
    console.log( this.a );
}

var a = 2;

foo(); // 2
```

foo()는 지극히 평범한 있는 그대로의 **날것** 같은 함수 호출이다.

#### 2. Implicit Binding

암시적 바인딩 (간접 바인딩) - 호출부에 컨텍스트 개체가 있는지
(referred to as an owning or containing object)

```javascript
function foo() {
    console.log( this.a );
}

var obj = {
    a: 2,
    foo: foo
};

obj.foo(); // 2
```

여기에서 주목할 점은 obj는 이 foo()함수를 소유(owning)하거나 포함(containing)한게 아니라는 점이다.
하지만 호출시 obj에서 foo() 함수를 참조하고 있다.
그러므로 obj객체는 함수 호출 시점에 함수의 레퍼런스를 소유(owning)하거나 포함(containing) 한다고 이야기 할수 있다.

콘텍스트 객체가 함수를 호출할 시 this로 바인딩이 되는데 이를 '암시적 바인딩' 이라 한다.
그러므로 foo() 호출시 obj는 this 이니 this.a == obj.a 가 된다.

```javascript
function foo() {
    console.log( this.a );
}

var obj2 = {
    a: 42,
    foo: foo
};

var obj1 = {
    a: 2,
    obj2: obj2
};

obj1.obj2.foo(); // 42
```
이것처럼 chain된 상황에서는 최상위, 최하위 (top/last) 의 정보만 호출부와 연관이 된다.

##### Implicitly Lost

```javascript
function foo() {
    console.log( this.a );
}

var obj = {
    a: 2,
    foo: foo
};

var bar = obj.foo; // function reference/alias!

var a = "oops, global"; // `a` also property on global object

bar(); // "oops, global"
```

여기에서 bar는 obj의 foo를 참조하는 변수처럼 보여지지만, foo를 직접 가르키는 또 다른 레퍼런스 이다.
또한 호출부에서는 기본 바인딩이 적용 되어 있으므로 'oops, global'이 출력 되었다.

```javascript
function foo() {
    console.log( this.a );
}

function doFoo(fn) {
    // `fn` is just another reference to `foo`

    fn(); // <-- call-site!
}

var obj = {
    a: 2,
    foo: foo
};

var a = "oops, global"; // `a` also property on global object

doFoo( obj.foo ); // "oops, global"
```

파라메터로 전달하는 건 일종의 암시적 할당 방법이다.
예제처럼 함수를 파라미터로 넘기면 암시적인 레퍼런스가 할당 되어 'oops, global' 이 출력 되는것이다.

내장함수의 경우도 살펴 보자

```javascript
function foo() {
    console.log( this.a );
}

var obj = {
    a: 2,
    foo: foo
};

var a = "oops, global"; // `a` also property on global object

setTimeout( obj.foo, 100 ); // "oops, global"

```

setTimeout() 의 구현체는 아래와 같은 것이다.

```javascript
function setTimeout(fn,delay) {
    // wait (somehow) for `delay` milliseconds
    fn(); // <-- call-site!
}
```

#### 3. Explicit Binding

명시적바인딩 -


#### 4. new Binding


### Everything In Order

모든것에는 순서가 있다.

#### Determining this

this 확정하는 규칙

### Binding Exceptions

바인딩이 예외가 되는 경우를 살펴 보자.

#### Ignored this

#### Indirection

우회적인 레퍼런스

#### Softening Binding

소프트 바인딩

### Lexical this

어휘적인 this


link : https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md
