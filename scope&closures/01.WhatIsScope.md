# What is Scope?

original document link : https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md

거의 모든 프로그래밍 언어의 가장 기본적인 패러다임 중 하나는
변수에 값을 저장하고 나중에 해당 값을 검색하거나 수정하는 기능입니다.
사실, 값을 저장하고 변수에서 값을 끌어낼 수있는 기능은 프로그램에 상태를 부여합니다.

이러한 개념이 없으면 프로그램은 몇 가지 작업을 수행 할 수 있지만,
매우 제한적이며 그닥 흥미롭지는 않을 것 입니다.

그러나 변수 개념을 프로그램에 넣으면, 이제 다루게 될 흥미로운 질문이 생깁니다
변수는 어디에 살아 있는가? 다른 말로, 그것들은 어디에 저장되어 있는가?
그리고 가장 중요한 것은, 프로그램이 그것을 필요로 할 때 어떻게 찾을 수 있는가?

이 질문은 어떤 위치에 변수를 저장하고
나중에 해당 변수를 찾는 규칙의 명확한 정의가 필요하다는 것을 말해줍니다.
우리는 그 규칙 집합을 Scope이라고 부를 것입니다.

These questions speak to the need for a well-defined set of rules
for storing variables in some location,
and for finding those variables at a later time.
We'll call that set of rules: Scope.

.

## 1. Compile

전통적인 컴파일 언어의 프로세스에서는 프로그램이 실행되기 전에
roughly called "Compilation"이라는 3단계를 거치게 됩니다.

1. 소스코드 추출(Tokenizing/Lexing)
2. 구문분석(Parsing)
3. 실행코드생성(Code-Generation)

실제로는 더 복잡하며, 자바스크립트는 실행 성능을 최적화하기 위해
그리고 즉시 실행되어야 하기 때문에, 좀 더 복잡한 단계 및 작업이 있습니다.

.

## 2. Scope

Engine : 자바스크립트 프로그램의 시작부터 끝내 컴파일 및 실행을 담당합니다.

Compiler : Engine의 친구 중 한 명. 파싱 및 코드 생성의 모든 더러운 작업을 처리합니다.

Scope : Engine의 또 다른 친구. 선언 된 모든 식별자 (변수)의 조회 목록을 수집하고 유지 관리하며, 현재 실행중인 코드에 액세스 할 수 있는 방법에 대한 엄격한 규칙을 적용합니다.

.

```javascript
var a = 2;
```

.

컴파일러는 다음과 같이 진행합니다.

- var a를 만나면 컴파일러는 Scope에 특정 범위 컬렉션에 대한 변수 a가 이미 있는지 확인합니다.
- 그렇다면 컴파일러는이 선언을 무시하고 계속 진행합니다.
- 그렇지 않으면 컴파일러는 Scope에 해당 범위 컬렉션에 대해 a라는 새 변수를 선언하도록 요청합니다.

- 그런 다음 컴파일러는 a = 2 할당을 처리하기 위해 나중에 실행할 코드를 생성합니다.
- 그 코드가 실행되면, 현재 Scope에 접근 가능한 변수가 있는지 먼저 Scope에 요청합니다.
- 그렇다면 엔진은 해당 변수를 사용합니다. 그렇지 않은 경우 엔진은 다른 곳에서 보입니다 (아래 중첩 된 범위 섹션 참조).

.

## LHS, RHS

Engine이 변수 a를 찾아서 선언되었는지 확인하는 작업은 scope을 참조합니다.
그러나 조회 엔진의 유형이 조회 결과에 영향을줍니다.
여기서, Engine은 변수 a에 대해 "LHS"검색을 수행 할 것이라고합니다.다른 유형의 조회는 "RHS"라고합니다.




## Nested scope
