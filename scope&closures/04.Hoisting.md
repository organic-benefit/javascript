# Chapter 4: Hoisting

## 닭이 먼저냐, 달걀이 먼저냐?
자바스크립트에서 볼 수 있는 모든 코드는 프로그램이 실행 될 때 줄 단위로, 위에서 아래로 해석된다고 생각할 수 있다.
실제로 그렇게 동작하지만, 잘못된 생각을 할 수 있는 부분이 있다.

아래의 코드를 보자 :

```js
a = 2;

var a;

console.log(a);
```

`console.log(...)` 의 결과가 무엇일까?

대부분의 개발자는 `var a` 가 `a = 2` 다음에 오므로, 변수가 재 정의 되어 변수의 기본 값인 undefined가 저장 되어있다고 생각할 것이다.
하지만, 결과는 2가 나온다.

다른 코드를 생각 해 보자:

```js
console.log(a);

var a = 2;
```
첫 번째 코드가 위에서 아래로 동작하지 않는 것을 보였기 때문에, 이 코드도 2를 출력할 것이라고 생각 할 수 있다.
다른 생각으로는 a 가 선언되기 전에 사용되었기 때문에 ReferenceError를 던질거라고 생각 할 수도 있다.

하지만 둘 다 틀린 생각이다. 결과는 undefined 가 된다.

이게 어떻게 되는 것인가? 위 결과들은 '선언(달걀)이 먼저 인가? 할당(닭)이 먼저 인가?' 라는 의문을 갖게 한다.

## 컴파일러를 다시 보자 
우리는 위 의문을 해소하기 위해 챕터 1과 컴파일러에 대해 다시 생각할 필요가 있다.
자바스크립트 엔진은 코드를 해석하기 바로 전에 컴파일 한다는 것을 떠올려라.
컴파일 단계에서 해당 스코프와 연관된 모든 선언을 찾는다.
2장에서 이것을 어휘 스코프의 핵심이라는 것을 보여주었다.

즉, 위의 것들을 이해하는데 가장 좋은 방법은 모든 선언(변수, 함수)들이 코드 실행 전에 우선적으로 처리된다고 생각하는 것이다.

보통 `var a = 2;` 를 1가지 문장으로 생각 할 수 도 있다.
하지만 자바스크립트는 `var a;` 와 `a = 2;` 의 2가지 문장으로 여긴다.
`var a;`(선언)은 컴파일 단계에서 처리 된다.
하지만 `a = 2;`(할당)은 코드 실행 단계에서 처리 된다.

그래서 맨 처음 코드를 아래와 같이 다시 생각 해보자 :
```js
var a;
```

```js
a = 2;

console.log(a);
```
위의 코드에서 첫 번째 부분은 컴파일 단계의 코드 상태이고, 두 번째 부분은 코드 실행 단계의 코드 상태이다.

비슷하게 두 번째 코드도 아래와 같이 다시 생각 할 수 있다 :
```js
var a;
```
```js
console.log(a);
a = 2;
```
이 처리 과정을 가장 쉽게 생각하는 방법은 모든 변수와 함수들은 맨 처음 나타났을 때의 위치에서 상위에 선언 되어 진다고 생각하는 것이다.

즉, 달걀(선언)은 닭(할당) 앞에 온다.

**참고** : 선언들은 어떤 할당이나 실행할 수 있는 로직이 있는 동안에만 끌어올려질 수 있다.
만약 호이스팅이 실행 흐름을 재조정 한다면, 혼란이 있을 수 있다.
```js
foo();

function foo() {
    console.log(a); // undefined

    var a = 2;
}
```
foo 함수 선언은 코드의 첫 번째 라인(foo();)가 실행되기 전에 호이스팅 될 것 이다.

호이스팅은 스코프 단위라는 것을 주의하자.
이 예제 전에는 전역 범위만 가진 단순한 예만 보았지만, 지금 보고 있는 `foo(...)` 함수는 `var a`가 `foo(...)`의 최상위로 올라간다는 것을 보여준다
(프로그램의 최상위를 말하는 것이 아님). 그래서 위의 코드는 아래와 같이 해석된다고 보는 것이 정확하다고 할 수 있다:
```js
function foo() {
    var a;

    console.log(a);     // undefined

    a = 2;
}

foo();
```
우리가 예상한대로 위와 같이 호이스팅되어 해석이 될 것이다. 하지만 함수 표현식은 또 다르게 동작한다.
```js
foo();      // not ReferenceError, but TypeError!

var foo = function bar() {
    // ...
},
```
변수 `foo` 는 호이스팅되어 이 프로그램에서 속한 스코프(여기서는 global)에 포함될 것이고, `foo()`가 ReferenceError로 실패하지 않는다.
하지만 변수 foo 는 아직 아무 값도 가지고 있지 않다(만약 함수 표현식이 아니라 선언식이라면 다름).
그래서 `foo()`는 undefined 상태로 어떠한 동작을 요청하는 함수를 호출하려 시도할 것이고, TypeError가 된다.

또한 이름이 있는 함수 표현식에서 이름은 스코프에 포함되지 않는다는 것을 떠올려라.
```js
foo();      // TypeError
bar();      // ReferenceError

var foo = function bar() {
    // ...
};
```
조금 더 정확하게 보자면:
```js
var foo;

foo();      // TypeError
bar();      // ReferenceError

foo = function() {
    var bar = ...self...
    //...
}
```
## 함수 우선
함수 선언식과 변수 선언 둘 다 호이스팅이 되며, 함수 선언식이 변수 선언보다 먼저 호이스팅이 된다(여기 예제는 함수명과 변수명이 중복일 경우만 보여줌).

아래를 생각 해 보자:
```js
foo();      // 1

var foo;

function foo() {
    console.log(1);
}

foo = function() {
    console.log(2);
};
```
2 대신에 1이 출력된다! 자바스크립트 엔진이 실제로 해석하는 것을 보자면 :
```js
function foo() {
    console.log(1);
}

foo();      // 1

foo = function() {
    console.log(2);
};
```
`var foo`가 `function foo()`보다 먼저 선언이 되어있더라도 중복 선언이 되어있기 때문에 무시한다는 것을 주목하자.
왜냐하면 함수 호이스팅이 변수 호이스팅보다 먼저 되기 때문이다.

중복된 `var` 선언은 무시하지만, 연속된 함수 선언은 오버라이드 된다.
```js
foo();      // 3

function foo() {
    console.log(1);
} 

var foo = function() {
    console.log(2);
};

function foo() {
    console.log(3);
}
```
별것 아닌 것처럼 보이지만, 동일한 스코프에서 중복 선언은 우리를 자주 혼란시키므로 사용하지 않는 것을 권한다.

일반 블록에 포함된 함수 선언들은 아래 코드가 의미하는 것처럼 조건부로 호이스팅 되는 것이 아니라, 해당 함수가 포함된 스코프에서 호이스팅 된다.
```js
foo();      // b

var a = true;
if(a) {
    function foo() {
        console.log("a");
    }
} else {
    function foo() {
        console.log("b");
    }
}
```
그러나, 후에 자바스크립트가 어떻게 바뀔지 모르므로 위의 코드는 불안정한 코드이며, 가장 좋은 것은 함수를 블록안에서 선언하지 않는 것 이다.

## Review
우리는 `var a = 2` 를 하나의 문장으로 볼 수 있지만, 자바스크립트 엔진은 다르다는 것을 알았다.
자바스크립트 엔진은 `var a` 와 `a = 2`처럼 2가지 문장으로 보며, 선언은 컴파일 단계에서 할당은 코드 실행단계에서 된다.

모든 선언들은 스코프 안에서 코드가 실행되기 전에 처리가 된다는 것 이다.
우리는 선언들이 스코프의 상단으로 '이동' 되는 것처럼 볼 수 있는데, 이를 '호이스팅'이라고 한다.

선언 자체는 호이스팅 되지만, 함수 표현의 할당을 포함한 할당 문장들은 호이스팅 되지 않는다.

중복 선언, 특히 var 선언과 함수 선언이 중복된 경우 큰 혼란을 가져올 수 있으므로 조심하라.

## Quiz
```js
foo();
bar();

var foo = function() {
    console.log("foo and x = " + x);
};

function bar() {
    console.log("bar and x = " + x);
}

var x = 1;
```

## Answer
```js
var foo;

function bar() {
    var x;
    console.log("bar and x = " + x);
}

var x;

foo();      // TypeError
bar();

foo = function() {
    console.log("foo and x = " + x);
};

x = 1;
```